---
title: 'lifecycle 0.1.0'
author: Lionel Henry
date: '2019-08-02'
slug: lifecycle-0-1-0
description: >
  lifecycle 0.1.0 is now on CRAN!
categories:
  - package
photo:
  url: https://unsplash.com/photos/hnUUZMxQwYk
  author: Nathana blt
---






It is with unmeasured exhilaration that we announce the release of [lifecycle 0.1.0](https://lifecycle.r-lib.org) on CRAN. lifecycle is a toolkit for managing the lifecycle of your exported functions with shared conventions, documentation badges, and non-invasive deprecation warnings.

The main goal of lifecycle is to streamline how the evolution of your exported API is communicated to your users. It achieves this by:

* Defining a set of stages that a function or argument can be in.

* Providing badges for each lifecycle stage that you can insert in your documentation.

* Providing a set of functions to signal deprecation warnings with increasing levels of non-invasive verbosity.

We started using these tools and conventions in r-lib and tidyverse packages a few months ago. We now make them available for all package developers. In this post, we'll briefly present the lifecycle workflow. Read the [Get started](http://lifecycle.r-lib.org/articles/lifecycle.html) vignette for a more complete description. Install the package from CRAN with:


```r
install.packages("lifecycle")
```



## Lifecycle stages

The stages for functions and arguments are modelled after the [lifecycle stages for packages](https://www.tidyverse.org/lifecycle/).  There are 4 __development__ stages. Then, if the decision of discontinuing a feature has been made, it goes through 3 __deprecation__ stages.

### Development stages

![](/images/lifecycle/lifecycle-experimental.svg)<!-- -->

An __experimental__ feature is in the very early stage of development. It is exported so users can start to use it and report feedback, but its interface and/or behaviour is likely to change in the future. It is generally best to avoid depending on experimental features.

![](/images/lifecycle/lifecycle-maturing.svg)<!-- -->

The interface and behaviour of a __maturing__ feature has been roughed out, but finer details are likely to change. It still needs more feedback to find the optimal API.

![](/images/lifecycle/lifecycle-stable.svg)<!-- -->

A feature is considered __stable__ when the author is happy with its interface and behaviour. Major changes are unlikely, and breaking changes will occur gradually, through a deprecation process.

![](/images/lifecycle/lifecycle-questioning.svg)<!-- -->

In the __questioning__ stage, the author is no longer convinced that the feature is the optimal approach. However, there are no recommended alternatives yet.


### Deprecation stages

When the author is no longer happy with a feature because they consider it sub-optimal compared to some other approach, or simply because they no longer have the time to maintain it, it goes through three stages of deprecation.

![](/images/lifecycle/lifecycle-soft-deprecated.svg)<!-- -->

A __soft-deprecated__ feature can still be used without hassle, but users should consider switching to an alternative approach.

![](/images/lifecycle/lifecycle-deprecated.svg)<!-- -->

A __deprecated__ feature is likely to be discontinued in the next major release. Users should switch to an alternative approach as soon as possible.

![](/images/lifecycle/lifecycle-defunct.svg)<!-- -->

A __defunct__ function is still exported, and a defunct argument is still part of the signature. However, the feature can no longer be used, it now throws an informative error.


### Adding lifecycle badges in documentation

You can insert the lifecycle badges anywhere in your documentation. First import the badges in your package:


```r
# At the time of writing, you need the development version of usethis
remotes::install_github("r-lib/usethis")
usethis::use_lifecycle()
```

Then use the Rd macro `\lifecycle{stage}`:


```r
#' \lifecycle{experimental}
#' \lifecycle{soft-deprecated}
```

You typically don't need to advertise the status of a function if it is the same as the package as a whole. For instance, if your package is [maturing](https://www.tidyverse.org/lifecycle/#maturing), only signal functions in the experimental, stable, questioning stages, or deprecated stages. A good place to include the lifecycle badge of a function is at the top of the `@description` block. If the function is deprecated, we recommend marking it as internal so it no longer appear in the help index:


```r
#' Recoup some local heads outside the sent staged changes
#'
#' @description
#'
#' \lifecycle{soft-deprecated}
#'
#' `git_recoup_head()` recoups any non-indexed downstream heads before a
#' few relinked local archives.
#'
#' @keywords internal
```

The lifecycle stage of your function is now clearly indicated in its documentation topic:

![](/images/lifecycle/recoup-deprecated.png)<!-- -->

To document the lifecycle stage of an argument, insert the badge in the argument description:


```r
#' @param indict_branch \lifecycle{deprecated}
#'
#'   If `FALSE`, `git_blend_tag()` parses references from
#'   the filter-branched upstream.
```

![](/images/lifecycle/indict-deprecated.png)<!-- -->


### Verbosity of deprecation

As is convention in R, usage of deprecated functions is signalled with warnings. However, lifecycle tries to warn in a non-invasive way. When a deprecated function is called multiple times, only the first time causes a warning. The function then works silently for the rest of the session.

There are two levels of verbosity for deprecated functions, depending on the lifecycle stage. For soft-deprecated features, the verbosity level is minimal. No warning is issued unless the function is called directly from the global environment or from unit tests. This is a way of starting to raise awareness about the deprecation of this function without affecting indirect users.

*   To signal (soft-)deprecation warnings, use `deprecate_soft()` and `deprecate_warn()`:

    
    
    ```r
    lifecycle::deprecate_soft("0.5.0", "mypkg::foo()")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Warning: `foo()` is deprecated as of mypkg 0.5.0.
    </pre></div>
    

    
    ```r
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Warning: `bar()` is deprecated as of mypkg 0.4.0.
    #&gt; <span style='color: #555555;'>This warning is displayed once per session.</span><span>
    #&gt; </span><span style='color: #555555;'>Call `lifecycle::last_warnings()` to see where this warning was generated.</span><span>
    </span></pre></div>

    You can optionally provide a replacement which will be mentioned in the warning message:

    
    ```r
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()", "otherpkg::quux()")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Warning: `bar()` is deprecated as of mypkg 0.4.0.
    #&gt; Please use `otherpkg::quux()` instead.
    #&gt; <span style='color: #555555;'>This warning is displayed once per session.</span><span>
    #&gt; </span><span style='color: #555555;'>Call `lifecycle::last_warnings()` to see where this warning was generated.</span><span>
    </span></pre></div>

*   When a function is ready to be effectively discontinued, use `defunct_stop()`:

    
    ```r
    lifecycle::deprecate_stop("0.4.0", "mypkg::bar()")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Error: `bar()` is deprecated as of mypkg 0.4.0.
    </pre></div>

*   To control the verbosity of deprecation, use the global option `lifecycle_verbosity`. It can be set to `"quiet"`, `"default"`, `"warning"`, or `"error"`:

    
    ```r
    options(lifecycle_verbosity = "error")
    
    lifecycle::deprecate_soft("0.5.0", "mypkg::foo()")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Error: `foo()` is deprecated as of mypkg 0.5.0.
    </pre></div>

    

    Setting the verbosity to `"warn"` forces warnings to occur each time the function is called, it is no longer shown once per session.

*   Provide additional details about the deprecation with the `details` argument:

    
    ```r
    details <- "Why this is discontinued"
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()", details = details)
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Warning: `bar()` is deprecated as of mypkg 0.4.0.
    #&gt; Why this is discontinued
    #&gt; <span style='color: #555555;'>This warning is displayed once per session.</span><span>
    #&gt; </span><span style='color: #555555;'>Call `lifecycle::last_warnings()` to see where this warning was generated.</span><span>
    </span></pre></div>

*   Finally, signal deprecated arguments with the following syntax:

    
    ```r
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar(old = )", "mypkg::bar(new = )")
    ```
    
    <div class = "output"><pre class="knitr r">#&gt; Warning: The `old` argument of `bar()` is deprecated as of mypkg 0.4.0.
    #&gt; Please use the `new` argument instead.
    #&gt; <span style='color: #555555;'>This warning is displayed once per session.</span><span>
    #&gt; </span><span style='color: #555555;'>Call `lifecycle::last_warnings()` to see where this warning was generated.</span><span>
    </span></pre></div>


### Deprecation of arguments

Deprecating arguments requires a little more work than deprecating functions because you need to make sure the function still interprets the argument correctly when it is supplied by the user. To help with this, lifecycle provides the `deprecated()` sentinel. All it does is return the missing argument, so you can test whether the argument was supplied explicitly with `rlang::is_missing()` (note that `base::missing()` doesn't work here because it doesn't support complex expressions). If you find the argument non-missing, signal the deprecation warning and handle the user input for compatibility:


```r
git_recoup_head <- function(unwind_head = TRUE, indict_branch = deprecated()) {
  if (!rlang::is_missing(indict_branch)) {
    # Signal deprecation
    lifecycle::deprecate_warn(
      when = "1.0.0",
      what = "git_recoup_head(indict_branch = )",
      with = "git_recoup_head(unwind_head = )"
    )

    # Compatibility
    unwind_head <- indict_branch
  }

  ...

  message("Recouped head of git repo")
}
```
