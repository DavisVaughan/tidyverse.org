---
title: 'lifecycle 0.1.0'
author: Lionel Henry
date: '2019-08-02'
slug: lifecycle-0-1-0
description: >
  lifecycle 0.1.0 is now on CRAN!
categories:
  - package
photo:
  url: https://unsplash.com/photos/hnUUZMxQwYk
  author: Nathana blt
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>"
)
```

```{r crayon, include = FALSE}
colourise_chunk <- function(x, options) {
  x <- pkgdown:::escape_html(x)
  sprintf(
    '<div class = "output"><pre class="knitr %s">%s</pre></div>\n',
    tolower(options$engine),
    fansi::sgr_to_html(x)
  )
}
knitr::knit_hooks$set(
  output = colourise_chunk,
  message = colourise_chunk,
  warning = colourise_chunk,
  error = colourise_chunk
)

options(crayon.enabled = TRUE)
```


It is with unmeasured exhilaration that we announce the release of [lifecycle 0.1.0](https://lifecycle.r-lib.org) on CRAN. lifecycle is a toolkit for managing the lifecycle of your exported functions with shared conventions, documentation badges, and non-invasive deprecation warnings.

The main goal of lifecycle is to provide a standard for communicating the evolution of your exported API to your users. It achieves this by:

* Defining a set of stages that a function or argument can be in.

* Providing badges for each lifecycle stage that you can insert in your documentation.

* Providing a set of functions to signal deprecation warnings with increasing levels of non-invasive verbosity.

We started using these tools and conventions in r-lib and tidyverse packages a few months ago. We now make them available for all package developers. In this post, we'll briefly present the lifecycle workflow. Read the [Get started](http://lifecycle.r-lib.org/articles/lifecycle.html) vignette for a more complete description. Install the package from CRAN with:

```{r, eval = FALSE}
install.packages("lifecycle")
```


## Lifecycle stages

The stages for functions and arguments are modelled after the [lifecycle stages for packages](https://www.tidyverse.org/lifecycle/).  There are four __development__ stages and four __termination__ stages.


### Development stages

The objective of the development stages is to find the right balance between exposing the function to too few users and too many users. If an experimental function is exclusively available in a development branch on Github, the author probably won't get a lot of feedback about its interface and its behaviour. If a function is exported and published on CRAN without any indication that it is experimental, too many people might start using it in other packages and in production code, unaware that the function is likely to change in the future.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-experimental.svg")
```

An __experimental__ feature is in the very early stage of development. It is exported so users can start to use it and report feedback, but its interface and/or behaviour is likely to change in the future. It is generally best to avoid depending on experimental features in packages or production code.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-maturing.svg")
```

The interface and behaviour of a __maturing__ feature has been roughed out, but finer details are likely to change. It still needs more feedback to find the optimal API.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-stable.svg")
```

A feature is considered __stable__ when the author is happy with its interface and behaviour. Major changes are unlikely, and breaking changes will occur gradually, through a deprecation process.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-questioning.svg")
```

In the __questioning__ stage, the author is no longer convinced that the feature is the optimal approach. However, there are no recommended alternatives yet.


### Termination stages

When the author is no longer happy with a feature because they consider it sub-optimal compared to some other approach, or simply because they no longer have the time to maintain it, it is no longer under development. In that case there are two possibilities: the feature may be kept in the package indefinitely for backward compatibility, or it can be removed from the package if the maintainer is prepared to make an API breakage.


#### Retired stage

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-retired.svg")
```

A __retired__ feature is no longer under active development, and a known better alternative is available. However, it is indefinitely kept in the package for backward compatibility. The author only makes the necessary changes to ensure that the function continues working. No new features will be added, and only the most critical of bugs will be fixed.


#### Deprecation stages

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-soft-deprecated.svg")
```

A __soft-deprecated__ feature can still be used without hassle, but users should consider switching to an alternative approach.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-deprecated.svg")
```

A __deprecated__ feature is likely to be discontinued in the next major release. Users should switch to an alternative approach as soon as possible. In the tidyverse, we strive to keep deprecated functions around for at least a year.

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/lifecycle-defunct.svg")
```

A __defunct__ function is still exported, and a defunct argument is still part of the signature. However, the feature can no longer be used, it now throws an informative error. In the tidyverse, we keep defunct functions around for a long time, so that users running old code with new packages still get pointed in the right direction for updating their scripts.


### Adding lifecycle badges in documentation

You can insert the lifecycle badges anywhere in your documentation. First import the badges in your package:

```{r, eval = FALSE}
# At the time of writing, you need the development version of usethis
remotes::install_github("r-lib/usethis")
usethis::use_lifecycle()
```

Then use the Rd macro `\lifecycle{stage}`:

```{r, eval = FALSE}
#' \lifecycle{experimental}
#' \lifecycle{soft-deprecated}
```

You typically don't need to advertise the status of a function if it is the same lifecycle stage as the host package. For instance, if your package is [maturing](https://www.tidyverse.org/lifecycle/#maturing), only signal functions in the experimental, stable, questioning stages, or deprecated stages. Declare the lifecycle stage of your package by adding a badge to your README file with `usethis::use_lifecycle_badge()`.

A good place to include the lifecycle badge of a function is at the top of the `@description` block. If the function is deprecated, we recommend marking it as internal so it no longer appear in the help index:

```{r, eval = FALSE}
#' Recoup some local heads outside the sent staged changes
#'
#' @description
#'
#' \lifecycle{soft-deprecated}
#'
#' `git_recoup_head()` recoups any non-indexed downstream heads before a
#' few relinked local archives.
#'
#' @keywords internal
```

The lifecycle stage of your function is now clearly indicated in its documentation topic:

```{r echo = FALSE}
knitr::include_graphics("/images/lifecycle/recoup-deprecated.png")
```

To document the lifecycle stage of an argument, insert the badge in the argument description:

```{r, eval = FALSE}
#' @param indict_branch \lifecycle{deprecated}
#'
#'   If `FALSE`, `git_blend_tag()` parses references from
#'   the filter-branched upstream.
```

```{r, echo = FALSE}
knitr::include_graphics("/images/lifecycle/indict-deprecated.png")
```


### Verbosity of deprecation

Deprecated functions use warnings to signal that you need to update your code. lifecycle tries to do this in a non-invasive way, as too many warnings are almost as annoying as an error. To avoid overwhelming you with warnings, lifecycle only warns the first time a deprecated function is used.

There are two levels of verbosity for deprecated functions, depending on the lifecycle stage. For soft-deprecated features, the verbosity level is minimal. No warning is issued unless the function is called directly from the global environment or from unit tests. This encourages package developers to update their code while minimally affecting people doing data analysis.

*   To signal (soft-)deprecation warnings, use `deprecate_soft()` and `deprecate_warn()`:

    ```{r, include = FALSE}
    # Soft-deprecation warnings are suppressed in the knitr eval env
    options(lifecycle_verbosity = "warning")
    ```
    ```{r}
    lifecycle::deprecate_soft("0.5.0", "mypkg::foo()")
    ```
    ```{r, include = FALSE}
    options(lifecycle_verbosity = "default")
    ```

    ```{r}
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()")
    ```

    You can optionally provide a replacement which will be mentioned in the warning message:

    ```{r}
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()", "otherpkg::quux()")
    ```

*   When a function is ready to be effectively discontinued, use `defunct_stop()`:

    ```{r, error = TRUE}
    lifecycle::deprecate_stop("0.4.0", "mypkg::bar()")
    ```

*   To control the verbosity of deprecation, use the global option `lifecycle_verbosity`. It can be set to `"quiet"`, `"default"`, `"warning"`, or `"error"`:

    ```{r, error = TRUE}
    options(lifecycle_verbosity = "error")

    lifecycle::deprecate_soft("0.5.0", "mypkg::foo()")
    ```

    ```{r, include = FALSE}
    options(lifecycle_verbosity = "default")
    ```

    Setting the verbosity to `"warn"` forces warnings to occur each time the function is called, it is no longer shown once per session.

*   Provide additional details about the deprecation with the `details` argument:

    ```{r}
    details <- "Why this is discontinued"
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar()", details = details)
    ```

*   Finally, signal deprecated arguments with the following syntax:

    ```{r}
    lifecycle::deprecate_warn("0.4.0", "mypkg::bar(old = )", "mypkg::bar(new = )")
    ```


### Deprecation of arguments

Deprecating arguments requires a little more work than deprecating functions because you need to make sure the function still interprets the argument correctly when it is supplied by the user. To help with this, lifecycle provides the `deprecated()` sentinel. All it does is return the missing argument, so you can test whether the argument was supplied explicitly with `rlang::is_missing()` (note that `base::missing()` doesn't work here because it doesn't support complex expressions). If you find the argument non-missing, signal the deprecation warning and handle the user input for compatibility:

```{r}
git_recoup_head <- function(unwind_head = TRUE, indict_branch = deprecated()) {
  if (!rlang::is_missing(indict_branch)) {
    # Signal deprecation
    lifecycle::deprecate_warn(
      when = "1.0.0",
      what = "git_recoup_head(indict_branch = )",
      with = "git_recoup_head(unwind_head = )"
    )

    # Compatibility
    unwind_head <- indict_branch
  }

  ...

  message("Recouped head of git repo")
}
```
