---
title: Self-cleaning test fixtures
author: Jenny Bryan
date: '2020-04-23'
slug: self-cleaning-test-fixtures
categories:
  - programming
  - learn
tags:
  - r-lib
description: |
  A 2-3 sentence description of the post that appears on the articles page.
photo:
  url: https://
  author: Jenny Bryan
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", 
  fig.width = 7, 
  fig.align = 'center',
  fig.asp = 0.618, # 1 / phi
  out.width = "700px"
)
```

TODO: does it need an intro?

## Test hygiene

> Take nothing but memories, leave nothing but footprints.

― Chief Si'ahl

Ideally a test should leave the world exactly as it found it. Examples of things you might do inside a test and, therefore, need to undo:

* Create a file or directory
* Create a resource on an external system
* Set an R option
* Set an environment variable
* Change working directory
* Change an aspect of the tested package's state

Scrupulous attention to cleanup is more than just courtesy or being fastidious. It is also self-serving. The state of the world after test `i` is the starting state for test `i + 1`. Tests that change state willy-nilly eventually end up interfering with each other in ways that can be very difficult to debug. Most tests are written with an **implicit** assumption about the starting state, usually whatever *tabula rasa* means for the target domain of your package. If you accumulate enough sloppy tests, I promise you that eventually some leftover piece of litter will cause (something something something).

> Using Microsoft word *moves picture 3mm left* All text shifts, four new pages appear, paragraph breaks form a union, in the distance, sirens.

— Amy Schwartz (schwartzanegger) February 11, 2016

<http://ctrlq.org/first/102402-word-moves-distance-sirens/>

First, we lay some foundations that aren't obviously related to tests, but just trust that we'll get there eventually.

##  The `on.exit()` pattern

If you want to clean up after yourself, how should you actually do it?

The first function to know about is base R's [`on.exit()`](https://rdrr.io/r/base/on.exit.html). You use it inside a function. In the function body, every time you do something that should be undone **on exit**, you immediately register the cleanup code with `on.exit(expr, add = TRUE)`.

*It's too bad `add = TRUE` isn't the default, because you almost always want this. Without it, each call to `on.exit()` clobbers the effect of previous calls.*

Here's a `sloppy()` function that prints a number with a specific number of significant digits.

```{r include = FALSE}
op <- options()
```

```{r}
sloppy <- function(x, sig_digits) {
  options(digits = sig_digits)
  print(x)
}

pi

sloppy(pi, 2)

pi
```

```{r include = FALSE}
options(op)
```

Notice how `pi` prints differently before and after the call to `sloppy()`. Calling `sloppy()` has a side effect: it changes the `digits` option globally, not just within its own scope of operations. This is what we want to avoid.

*Don't worry, I'm restoring global state behind the scenes here.*

Here's how to do better with `on.exit()`.

```{r}
neat <- function(x, sig_digits) {
  op <- options(digits = sig_digits)
  on.exit(options(op), add = TRUE)
  print(x)
}

pi

neat(pi, 2)

pi
```

The use of `on.exit()` ensures that `neat()` leaves `digits` the way that it found it. `on.exit()` also works when you exit the function abnormally, i.e. due to error. This is why it's a better choice than any do-it-yourself solution.

But I promised to talk about tests! Never fear, `on.exit()` also works inside a test.

```{r}
library(testthat)

exp(1)

test_that("on.exit() works in a test", {
  op <- options(digits = 2)
  on.exit(options(op), add = TRUE)
  out <- format(exp(1))
  expect_equal(out, "2.7")
  # printing just for the benefit of the reader
  print(out) 
})

exp(1)
```

*For related reading, see the section about [Exit handlers](https://adv-r.hadley.nz/functions.html#on-exit) in Advanced R.*

`on.exit()` is a very useful function and provides enough inspiration for an entire package: withr ([withr.r-lib.org](http://withr.r-lib.org)), which is a Swiss army knife for managing state in very flexible ways. It's what I usually use, in functions and tests, for situations like that above.

## `withr::defer()`

`withr::defer()` is a more general version of `on.exit()`. It can run cleanup for any environment, but defaults to the environment it was called in. Therefore, it works like `on.exit()` inside a function -- an extremely important special case -- but the added flexibility means you can use it in more complicated situations.

Below I compare `on.exit()` and `withr::defer()` and I put the code inside `local()`, instead of inside a function. This is meant to reinforce that cleanup can be relevant beyond function execution environments. It also gives you another tool to play with, in addition to toy functions and tests, in your own explorations of how to manage scope.

```{r}
library(withr)

local({
  on.exit(print("first"))
  on.exit(print("last"))  # this clobbers `print("first")` :(
})

local({
  on.exit(print("first"), add = TRUE)
  on.exit(print("last"), add = TRUE)
})

local({
  on.exit(print("first"), add = TRUE, after = FALSE)
  on.exit(print("last"), add = TRUE, after = FALSE)
})

local({
  defer(print("first"))
  defer(print("last"))
})
```

This showcases the nice ergonomics of `defer()`: each call *adds* to the list of deferred tasks (vs. replaces) and, by default, adds to the *front* of the stack (vs. the back). As you'll see below, this turns out to matter in most real world usage.

## `withr::local_*()`

`on.exit()` usage has a very predictable, slightly clunky pattern. In `neat()`, it looks like:

```{r eval = FALSE}
op <- options(digits = sig_digits)
on.exit(options(op), add = TRUE)      
```

First, you capture the current state. Then you make the desired state change. If you call a setter that returns the previous state, as `options()` does, these two steps can be combined. Last, you schedule the associated cleanup.

What if such a maneuver happens all over your package and you want to write a helper?

You can't wrap `on.exit()` in your own helpers, because there's no way to reach back up into the correct parent frame and schedule cleanup there. But with `defer()`, we can! Here is such a custom helper, called `local_digits()`.

```{r}
local_digits <- function(sig_digits, env = parent.frame()) {
  op <- options(digits = sig_digits)
  defer(options(op), env = env)
}
```

We can use it to keep any manipulation of `digits` local to a test (or function).

```{r}
exp(1)

test_that("withr lets us write custom helpers for local state manipulation", {
  local_digits(20)
  print(exp(1))
})

exp(1)

test_that("we can even make multiple calls to local_digits()", {
  local_digits(1)
  print(exp(1))
  local_digits(3)
  print(exp(1))
  local_digits(5)
  print(exp(1))
})

exp(1)
```

The ability to write `on.exit()`-like functions, customized to your own needs, is very empowering. However, you may not even need to. There are certain state changes that come up over and over again, for all of us. These are pre-implemented in withr's `local_*()` family of functions. A few examples:

| Do / undo this              | withr function    |
|-----------------------------|-------------------|
| Create a file               | `local_file()`    |
| Set an R option             | `local_options()` |
| Set an environment variable | `local_envvar()`  |
| Change working directory    | `local_dir()`     |

"Local" here refers to the fact that the state change persists only for the lifetime of an associated environment, usually the execution environment of a function or test.

We can use `withr::local_options()` to write yet another version of `neat()`:

```{r}
neat2 <- function(x, sig_digits) {
  local_options(list(digits = sig_digits))
  print(x)
}

pi

neat2(pi, 3)

pi
```

Each `local_*()` function has a companion `with_()` function, which is a nod to [`with()`](https://rdrr.io/r/base/with.html). We won't use the `with_*()` functions here, but you can learn more about them at [withr.r-lib.org](http://withr.r-lib.org).

## Test fixtures

Testing is often demonstrated with cute little tests and functions where all the inputs and expected results can be inlined. But in real packages, things aren't always so simple. The main functions in your package probably aren't "1 number in, 1 number out". They might require more exotic objects or very specific circumstances. Changing state might be the entire purpose of a function! Now what?

*Obligatory caveat: If you find it hard to write tests, this may be the universe telling you that your package has some design problems. Maybe you've somehow ended up with a small number of monster functions, with oodles of arguments, that can do everything from scramble eggs to change a lightbulb. The best move in this case may be to break things up into smaller and simpler functions. And those will be easier to test. End caveat.*

Tricky test situations can't always be eliminated by better package design. ?Something about [essential complexity](https://en.wikipedia.org/wiki/Essential_complexity)? Let's assume you've got a reasonable design and you're still facing some test dilemmas. Unless you find a way to make writing tests as pleasant as possible, you won't write nearly enough of them.

One technique I've found useful is what I'll call a **self-cleaning test fixture**.

### usethis and local packages

The usethis package ([usethis.r-lib.org](https://usethis.r-lib.org)) provides many functions for looking after the files and folders in an R project, especially an R package. These function names should give you a vague sense of what usethis does: `create_package()`, `use_vignette()`, `use_testthat()`, `use_github()`. Many of these functions only make sense in the context of an R package. That means in order to test them, we have to be working inside an R package.

We need a way to quickly spin up a minimal package, in the session temp directory. Test some functions against it. Then destroy it. Without a lot of fuss. We need a **local package**.

```{r}
local_package <- function(dir = file_temp(), env = parent.frame()) {
  old_project <- proj_get_()            # --- Record existing state --- 
  
  withr::defer({                        # --- Defer The Undoing --- 
    proj_set(old_project, force = TRUE) # restore active usethis project (-C)
    setwd(old_project)                  # restore working directory      (-B)
    fs::dir_delete(dir)                 # delete the temporary package   (-A)
  }, envir = env)
                                        # --- Do The Doing ---      
  create_package(dir, open = FALSE)     # create new folder and package  (A)
  setwd(dir)                            # change working directory       (B)
  proj_set(dir)                         # switch to new usethis project  (C)
  invisible(dir)
}
```

That's a simplified version of the test helper^[*] we use over 170 times in the usethis tests. Here's an example of how `local_package()` is used in a test:

[*] `local_package()` is a test helper. The testthat package allows such things to be defined in `tests/testthat/helper.R` and then makes them available within package tests. They are also loaded by `devtools::load_all()`. It's also a great place to define custom expectations.

```{r eval = FALSE}
test_that("use_roxygen_md() adds DESCRIPTION fields", {
  skip_if_not_installed("roxygen2")
  
  pkg <- local_package() # <<<<<------------------------ HERE IT IS!!!!!
  
  use_roxygen_md()
  
  expect_identical(
    desc::desc_get("Roxygen", pkg),
    c(Roxygen = "list(markdown = TRUE)")
  )
  expect_true(desc::desc_has_fields("RoxygenNote", pkg))
  expect_true(uses_roxygen_md())
})
```

This test checks that `usethis::use_roxygen_md()` does the setup necessary to use roxygen2 in a package and, specifically, to write documentation with markdown syntax. All 3 expectations consult the DESCRIPTION file, directly or indirectly. So it's very convenient that `local_package()` creates a minimal package, with a valid DESCRIPTION file, for us to test against. And when the test is done -- poof! -- the package is gone.

The setup and teardown done by `local_package()` would be aggravating and repetitive to inline in each individual test. The tests would be dominated by this code, making them less readable. If we need to tweak something, we'd have to do it in hundreds of places. This sort of friction has a real chilling effect on one's enthusiasm for writing and maintaining tests.
    
A few more observations about the self-cleaning test fixture pattern:

  * Every action has an equal and opposite reaction. Each individual "doing"
    action (A) has a matching, deferred "undoing" reaction (-A).
  * We work in this order (usually and preferably):
    - Record existing state.
    - Describe the eventual cleanup.
    - Make the desired state change.
  * The undoing usually unfolds in the opposite order from the doing ("last in,
    first out"). This is almost always OK and it is often absolutely necessary.
    In `local_package()`, we must create directory `dir` (A) before we can make
    it the working directory (B). When undoing, we must restore the original
    working directory (-B) before we can delete `dir` (-A).
    
**Test fixture** is a pre-existing term in the software engineering world (and beyond):

> A test fixture is something used to consistently test some item, device, or piece of software.

-- [Wikipedia](https://en.wikipedia.org/wiki/Test_fixture)

When I first heard "test fixture" (from Gábor Csárdi, I think), a light bulb clicked on in my head. This was something I *knew* I needed and had even implemented in various half-baked ways. But I hadn't identified it as A Real Thing, with specific goals and design principles. It's a great example of [hypocognition](https://blogs.scientificamerican.com/observations/unknown-unknowns-the-problem-of-hypocognition/). Learning the term "test fixture" gave me a place to hang this knowledge and allowed me to more quickly identify situations where a test fixture was needed.

### googlesheets4 and temporary spreadsheets

The googlesheets4 package ([googlesheets4.tidyverse.org](https://googlesheets4.tidyverse.org)) provides an R interface to the Google Sheets API. A typical test needs access to a Google Sheet, constructed to have very specific properties and the test may even need to modify the Sheet. *You might ask about mocking here, but I usually don't embrace that heavily and, in any case, that is a topic for another day.*

I need a way to quickly create a Sheet, possibly with very specific initial worksheets, cell data, locale, time zone, etc. Test some functions against it. Then trash it. I need a *temporary spreadsheet*. I use "temporary" instead of "local" here, since the main fixture lives elsewhere, i.e. on Google's servers.

Here's a simplified version of the helper `temp_ss()`:

```{r}
temp_ss <- function(name, ..., env = parent.frame()) {
  existing <- gs4_find(name)
  if (nrow(existing) > 0) {
    stop_glue("A spreadsheet named {sq(name)} already exists.")
  }

  withr::defer({
    trash_me <- gs4_find(name)
    googledrive::drive_trash(trash_me)
  }, envir = env)
  
  gs4_create(name, ...)
}
```

Even though the Sheets API is very file-ID-oriented, I go out of my way to work here via Sheet name. I bring this up to illustrate another point: you can also use a helper like this to rationalize your development workflow.

At first, it feels like `temp_ss()` should create a new Sheet, store its ID, and then schedule it for deletion. But reality is more messy. As I develop a function and its tests, my experimentation can leave behind several instances of a test Sheet (yes, on Drive, you can have several files with the same name!). This leads to a very cluttered and confusing situation in the test account, necessitating the occasional "search and destroy" mission for zombie test Sheets. Now my helper immediately alerts me to this problem and applies constant pressure to keep things neat and tidy.

If you keep stubbing your toe in a particular way as you work on your package, zoom out and consider if you can design the problem away by adjusting your workflow. The helper that creates a self-cleaning test fixture is great place to apply this sort of leverage.

## `defer()` on the global environment

I conclude with one more story about workflow. We've talked about two main functions for registering deferred events: base R's `on.exit()` and `withr::defer()`. Part of what `withr::defer()` offers over `on.exit()` is the ability to defer events on *any* environment. But there was still a big exception: the global environment.

Until quite recently, here's what happened if you called `defer()` in an interactive R session:

```{r eval = FALSE}
withr::defer(print("hi"))
#> Error in withr::defer(print("hi")):
#>   attempt to defer event on global environment

packageVersion("withr")
#> [1] '2.1.2'
```

This makes a lot of sense. Deferred events are triggered when an environment goes out of scope. `on.exit()` and `defer()` are meant to be used in an ephemeral environment, like a function execution environment. Deferring events on the global environment is pretty weird.

But what about your interactive development of functions and tests? Every time you hit a call to `defer()` or `local_*()`, that code fails to execute. You're forced to develop your logic at arm's length or implement the intent of the `local_*()` calls manually. It can be tricky to develop with functions that work one way inside a function, but another way in the global environment (or that don't work at all). `substitute()` is an example of this.

As of withr v2.2.0, you can `defer()` events on the global environment, which means that `local_*()` functions work too. This is still a pretty weird thing to do, which is why you get a message about how to trigger execution.

```{r eval = FALSE}
library(withr)

packageVersion("withr")
#> [1] '2.2.0'

defer(print("hi"))
#> Setting deferred event(s) on global environment.
#>   * Execute (and clear) with `deferred_run()`.
#>   * Clear (without executing) with `deferred_clear()`.

deferred_run()
#> [1] "hi"
```

Since the global environment isn't perishable, like a test environment is, you have to call `deferred_run()` explicitly to execute the deferred events. You can also clear them, without running, with `deferred_clear()`.

This new capability is especially handy with self-cleaning test fixtures, like `local_package()` and `temp_ss()` shown above. Sometimes you have to change state while developing tests, e.g. change working directory or create test Sheets. But now there's a way to run the associated cleanup on demand.

TODO: add a conclusion?

## TODOs

Settle on the actual photo. Probably some R-Ladies cat.

Fill in the something something something part / deal with the Microsoft Word example.

Do we have more to say about why/how `on.exit()` works in tests? Reading the docs, that appears to be off-label use.

Write the sentence about essential complexity.

Change the name of the helper in usethis.

Fix the footnote attempt. If successful, maybe turn more italicized asides into footnotes.

`scoped_temporary_ss()` from googlesheets. Rename it. Update it for current withr.

Why withr instead of `on.exit()`? Don't see how to work this in but ...

  * From @hadley re: being able to compose calls to `local_*()`
    functions (withr built-ins or homegrown) and something like `local_package()`
        test_that("...", {
          local_options(2)
          pkg <- local_package()
        })
  
Other thoughts:

  * Same mentality makes sense in other contexts, like examples. But hard to implement within CRAN guidelines.
  * Gee Paw has some interesting ?tweets? or ?posts? about creating test fixtures.
